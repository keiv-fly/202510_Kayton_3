## Kayton: End-to-end Implementation Steps

This is a practical, sequenced plan to implement the Kayton language system described in `20251004_starting_design_main.md` and `design/20251004_starting_design_preliminary.md`. It delivers a working hybrid (AOT + VM fallback) pipeline with clear milestones, definitions of done, and testable artifacts.

Use this as your single source of truth for execution. Each phase ends with a stable checkpoint you can tag and demo.

---

### Phase 0 — Tooling, repo, and conventions

- [ ] Install toolchain: Rust stable + `rustfmt`, `clippy`, `cargo-nextest`, `cargo-insta`, `cargo-llvm-cov`.
- [ ] Initialize monorepo layout with a Cargo workspace and `xtask/`.
- [ ] Add CI (GitHub Actions) for build, lint, tests, coverage; cache cargo.
- [ ] Decide coding standards: module naming, error handling, logging, feature flags.
- [ ] Add `CONTRIBUTING.md`, `CODE_OF_CONDUCT.md`, and top-level `README.md` (high-level usage and roadmap).

Definition of Done
- Workspace builds (empty crates OK), `cargo clippy --all -- -D warnings` passes, CI green.

Artifacts
- Workspace scaffolding; CI workflow file; `xtask` with commands: `fmt`, `lint`, `dev:check`.

---

### Phase 1 — Front-end baseline (`kayton-front`)

- [ ] Create `crates/kayton-front`.
- [ ] Implement tokenization (lexer) with spans and basic error recovery.
- [ ] Implement a minimal parser that produces a desugared HIR (no semantics yet):
  - Modules, `let` bindings, functions, calls, literals, if/while, block, return.
  - Unique IDs for HIR nodes; interner for symbols; source map for diagnostics.
- [ ] Implement `lowering` (surface syntax → HIR core forms) with deterministic node ordering.
- [ ] Public facade: `parse_to_hir(Path) -> HirModule`.

Definition of Done
- Parsing errors are reported with spans; golden tests verify parse trees and desugaring.

Artifacts
- HIR data structures, lexer/parser, desugaring tests (insta snapshots), `parse_to_hir` API.

---

### Phase 2 — Fast path (bytecode) MVP

Crates: `kayton-sema` (fast), `kayton-bytecode`, `kayton-emitter-bc`, `kayton-vm`, `kayton-cli`.

- [ ] `kayton-sema::fast`: name resolution, trivial typing, simple const-fold; annotate HIR with lightweight types where obvious.
- [ ] `kayton-bytecode`: define minimal ISA and constant pool (literals, names, function refs). Add verifier skeleton.
- [ ] `kayton-emitter-bc`: lower HIR + FastSema annotations into bytecode module.
- [ ] `kayton-vm`: interpret minimal ISA; HPy-style handle model stub for host calls (no host yet).
- [ ] `kayton-cli run <file.ktn>`: front → fast sema → emitter → vm.

Definition of Done
- Run simple programs: arithmetic, conditionals, functions, recursion.
- Golden tests for encoding; VM instruction tests; E2E `kayton run` tests.

Artifacts
- `.kbc` serialization format v0; VM interpreter core loop; CLI command `run`.

---

### Phase 3 — ABI, host, and stdlib stubs

Crates: `kayton-abi`, `kayton-api`, `kayton-host`, `kayton-plugin-macros`, `kayton-stdlib`.

- [ ] `kayton-abi`: define C ABI structs (context, handle, vtable), function calling convention, error codes.
- [ ] `kayton-api`: safe Rust wrappers (RAII handle, errors), conversions `KayVal ↔ Rust`.
- [ ] `kayton-plugin-macros`: `#[kayton_extension]` to export host functions/types.
- [ ] `kayton-host`: dynamic loader and registry; discover extensions; resolve by name/slot.
- [ ] `kayton-stdlib`: add a few host functions (print, len, math); build as rlib + dylib.
- [ ] VM path: `CALL_HOST` and `CALL_HOST_DYNAMIC` ops resolved through the ABI.

Definition of Done
- Example plugin crate compiled and loaded; `kayton run` can call host functions via ABI.

Artifacts
- ABI spec doc; sample plugin; basic stdlib exposed to VM.

---

### Phase 4 — Deep semantics and AOT rewriter

Crates: `kayton-sema` (deep), `kayton-rewriter-aot`.

- [ ] `kayton-sema::deep`: whole-program constraint solving, generics handling, trait/interface resolution, devirtualization plan, inlining hints, effect/refined types (scoped).
- [ ] Stable `HirId` mapping into constraints; diagnostics with notes and spans.
- [ ] `kayton-rewriter-aot`: materialize results into HIR′ or Kayton+ source:
  - Insert explicit types, monomorphize, lower trait sugar to direct calls.
  - Lower AOT-only features to core forms.
  - Mark non-lowerable sites as thunk candidates with stable `thunk_id`.
- [ ] CLI: `kayton aot rewrite <file.ktn> -o file.kayton+`.

Definition of Done
- Pretty-printed Kayton+ is stable and human-readable; golden tests for representative programs.

Artifacts
- Constraint engine with tests; rewriter library; `aot rewrite` CLI.

---

### Phase 5 — Rust backend and runtime shim

Crates: `kayton-backend-rust`, `kayton-rt`.

- [ ] `kayton-backend-rust`: generate Rust code from HIR′ with direct calls to std/plugins when possible.
- [ ] Fallback sites: emit Rust stubs that call into `kayton-rt::exec_bytecode_thunk(thunk_id, args)`.
- [ ] Bundle bytecode blobs into the output (link-section or `include_bytes!`), generate a thunk registry function.
- [ ] `kayton-rt`: provide execution bridge, arg/result marshalling, thunk registry, optional feature `embed_vm` that links VM directly.
- [ ] CLI: `kayton aot build <file.ktn>` to produce a native binary (uses cargo under the hood).

Definition of Done
- A small program builds to a native binary and runs; stubs call into runtime correctly.

Artifacts
- Generated Rust crate per build; bytecode embedding; runtime library with `exec_bytecode_thunk`.

---

### Phase 6 — Hybrid execution modes

- [ ] Default `--hybrid`: link `kayton-rt` with `embed_vm`; embed thunk blobs; register on startup.
- [ ] `--aot-strict`: fail the build if any thunk is generated.
- [ ] `--hybrid=dynamic`: do not link VM; load VM via `kayton-host` at runtime.
- [ ] CLI UX: `kayton aot build --aot-strict`, `--hybrid=dynamic`, `kayton aot explain --thunks`.

Definition of Done
- Three modes are selectable; integration tests cover each; `explain --thunks` lists thunk sites with spans.

Artifacts
- Mode switches, reporting, and documentation.

---

### Phase 7 — Testing, fuzzing, and performance

- [ ] Golden tests for front-end (parse/Lower), rewriter (Kayton+), and bytecode encoding.
- [ ] E2E tests: VM path, AOT path, hybrid fallback.
- [ ] Fuzzers: lexer, parser, bytecode verifier, VM instruction decoder.
- [ ] Benchmarks: VM throughput (hot loop), AOT binary startup, ABI call overhead.
- [ ] Coverage gating in CI; minimum thresholds.

Definition of Done
- Test packs stable; CI shows coverage; basic perf baselines recorded.

Artifacts
- `kayton-testing` crate with harness utilities; benchmark reports.

---

### Phase 8 — Developer experience and docs

- [ ] `kayton explain types --site <hir_id>`: dump deep constraints/solution and rewritten excerpt.
- [ ] `kayton inspect bytecode <file.kbc>`: pretty-print module, control-flow, constants.
- [ ] Add book-style docs under `docs/` covering: language overview, CLI, plugin authoring, hybrid system.

Definition of Done
- Usable explain/inspect tools; docs published; examples compile and run.

Artifacts
- Developer docs; CLI subcommands; example programs and plugins.

---

### Phase 9 — Hardening and release

- [ ] Deterministic IDs and thunk numbering across builds.
- [ ] Cache DeepSema summaries; incremental rebuild of affected units only.
- [ ] Error messages with actionable help and source highlights; lint groups (`aot_only_feature`).
- [ ] License review; release notes; versioning policy; crate publishing strategy.

Definition of Done
- 0.x release cut; binaries shipped; installation instructions validated on Windows/macOS/Linux.

Artifacts
- Tagged release; changelog; install script; published crates.

---

## Detailed task breakdown by crate

Use this section as a checklist while implementing.

### `kayton-front`
- Lexer with token kinds, numeric/string literals, identifiers, keywords, comments.
- Parser (LL/Pratt) for expressions/statements; error recovery; precedence rules.
- HIR types: module/function/param/block/expr/stmt; `HirId`, `Span`, `Symbol`.
- Lowering passes: syntactic sugar → core forms (e.g., `for` → `while`).
- Diagnostics: error types, labels, notes; render with spans.

### `kayton-sema`
- `fast`: scope stack, symbol table, builtins; trivial type inference and constants.
- `deep`: constraints, unification, trait resolution, monomorphization, devirtualization, inlining plan; effects (scoped). Deterministic solutions.

### `kayton-bytecode`
- ISA: constants, stack ops, control flow, calls, host calls.
- Serializer/deserializer; verifier (stack discipline, indices, types when available).

### `kayton-emitter-bc`
- HIR traversal to bytecode; constant pool building; function table; metadata.

### `kayton-vm`
- Interpreter loop; value representation; call frames; host call bridge; optional inline caches.

### `kayton-abi` / `kayton-api` / `kayton-host` / `kayton-plugin-macros`
- ABI structs and function signatures; error codes; versioning.
- Safe wrappers and conversions; dynamic library loader; registry.
- Proc-macro to export plugin functions with metadata.

### `kayton-stdlib`
- Core utilities: printing, math, collections adapters, OS stubs where safe.

### `kayton-rewriter-aot`
- Type insertion, specialization, devirtualization; lowering AOT-only features; pretty-printer for Kayton+.

### `kayton-backend-rust`
- Rust codegen for HIR′; direct calls to std/plugins; stub generation for thunks; bytecode bundling; deterministic `thunk_id` mapping.

### `kayton-rt`
- Thunk registry; `exec_bytecode_thunk(thunk_id, args)`; `embed_vm` feature; dynamic VM loading via `kayton-host`.

### `kayton-cli`
- Subcommands: `run`, `aot rewrite`, `aot build`, `aot explain --thunks`, `explain types`, `inspect bytecode`.

### `kayton-testing`
- Golden test infra; fixtures; fuzzers; benches; coverage config.

---

## Milestones (recommended)

1. M0: Repo + CI green with empty crates.
2. M1: `kayton run` executes arithmetic and simple functions via VM.
3. M2: Host calls via ABI + stdlib basics.
4. M3: `aot rewrite` produces stable Kayton+ for sample programs.
5. M4: `aot build` produces native binary; some functions stubbed to VM thunks.
6. M5: Hybrid modes implemented; `--aot-strict` and `--hybrid=dynamic` functional.
7. M6: DX tools (`explain`, `inspect`), fuzz/benches, docs published.
8. M7: 0.x release with installers.

---

## Risks and decision points

- Value representation unification across VM and AOT runtime.
- Determinism of IDs/thunks; must be reproducible across platforms/CI.
- Scope of effects/refined types in first release; avoid blocking AOT MVP.
- Dynamic loading security and versioning of ABI.

Mitigations
- Freeze minimal KayVal and ABI early; add version fields.
- Deterministic traversal/orderings; seedable hashing; stable symbol interning.
- Feature-gate advanced type features until Phase 4 completes.
- Sign or checksum plugins; enforce ABI version checks.

---

## Developer loops

- `xtask fmt` → `xtask lint` → `cargo nextest run -p kayton-*` → `cargo insta review`.
- `kayton run examples/*.ktn` for fast path.
- `kayton aot rewrite/build` for AOT/hybrid.
- `RUST_LOG=kayton_*=debug` for tracing (consider `tracing` crate + `tracing-subscriber`).

---

## References

- See unified architecture in `20251004_starting_design_main.md` for crate purposes and data flow.
- Preliminary notes in `design/20251004_starting_design_preliminary.md` for rationale and alternatives.


