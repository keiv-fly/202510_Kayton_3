# Kayton Roadmap (v0.x)

_Date: 2025-10-08_

This roadmap synthesizes the design intent and implementation plan from:
- `design/20251004_starting_design_main.md` (hybrid AOT/VM architecture)
- `design/20251004_starting_design_preliminary.md` (workspace/data-flow details)
- `design/20251001_look of the language.md` (surface rules and syntax direction)
- `design/20251004 steps.md` (end-to-end implementation steps)

## Objectives (high-level)
- Dual-mode execution: latency-first bytecode VM + AOT-to-Rust native binaries.
- Hybrid fallback: AOT binaries run embedded bytecode thunks for non-lowerable sites.
- Unified front-end/HIR and shared ABI across VM and AOT paths.
- Developer-first CLI with symmetrical commands for run, rewrite, build, explain.
- Deterministic builds (stable IDs, thunk numbering) and strong testing/CI.

## Success metrics
- Can run simple programs via VM within Phase 2 (M1).
- Can AOT-rewrite to Rust and build native binaries with hybrid fallback by Phase 5 (M4).
- Hybrid modes selectable (`--aot-strict`, `--hybrid=dynamic`) by Phase 6 (M5).
- Golden tests stable; coverage and perf baselines recorded by Phase 7 (M6).
- 0.x release published with installers and docs by Phase 9 (M7).

---

## Phases and Deliverables

### Phase 0 — Tooling, repo, and conventions
- Objectives: Set up Cargo workspace, CI, and dev ergonomics (`xtask`).
- Key tasks: rustfmt/clippy/nextest/llvm-cov; workspace init; CONTRIBUTING/CODE_OF_CONDUCT/README; `xtask fmt|lint|dev:check`.
- Definition of Done: Workspace builds (empty crates OK), clippy `-D warnings` passes.
- Dependencies: None.

### Phase 1 — Front-end baseline (`kayton-front`)
- Objectives: Lexer, parser, HIR + lowering, public facade.
- Key tasks: Spans, interner, stable `HirId`; desugaring to core forms; `parse_to_hir(Path) -> HirModule`.
- DoD: Diagnostics with spans; golden tests (insta) for parse trees and lowering.
- Dependencies: Phase 0.

### Phase 2 — Fast path (bytecode) MVP
- Crates: `kayton-sema` (fast), `kayton-bytecode`, `kayton-emitter-bc`, `kayton-vm`, `kayton-cli`.
- Objectives: Run small programs through VM.
- Key tasks: FastSema (names, trivial typing, const-fold); minimal ISA + verifier skeleton; emitter; interpreter; `kayton run <file.ktn>`.
- DoD: Arithmetic, conditionals, functions, recursion work; encoding and VM tests; E2E `kayton run` passing.
- Dependencies: Phase 1.

### Phase 3 — ABI, host, and stdlib stubs
- Crates: `kayton-abi`, `kayton-api`, `kayton-host`, `kayton-plugin-macros`, `kayton-stdlib`.
- Objectives: Host call bridge with a minimal stdlib and plugin demo.
- Key tasks: HPy-style context/handles/vtable; safe wrappers; dynamic loader and registry; `#[kayton_extension]`; `CALL_HOST`/`CALL_HOST_DYNAMIC` in VM.
- DoD: Example plugin loads; `kayton run` can call host functions via ABI.
- Dependencies: Phase 2.

### Phase 4 — Deep semantics and AOT rewriter
- Crates: `kayton-sema` (deep), `kayton-rewriter-aot`.
- Objectives: Whole-program constraint solving; materialize HIR′ or Kayton+.
- Key tasks: Generics/traits resolution, monomorphization, devirtualization, effect/refined types (scoped); rewriter inserts explicit types, lowers AOT-only features, marks thunk candidates.
- DoD: Stable, readable Kayton+ output; golden tests for representative programs; diagnostics with spans and notes.
- Dependencies: Phases 1–3.

### Phase 5 — Rust backend and runtime shim
- Crates: `kayton-backend-rust`, `kayton-rt`.
- Objectives: Generate Rust from HIR′; provide runtime with thunk execution and marshalling.
- Key tasks: Direct Rust calls where possible; generate stubs calling `kayton-rt::exec_bytecode_thunk(thunk_id, args)`; bundle bytecode; thunk registry; `embed_vm` feature.
- DoD: `kayton aot build` produces a native binary; hybrid execution works for fallback sites.
- Dependencies: Phase 4 (rewriter), Phase 2/3 (bytecode artifacts, ABI).

### Phase 6 — Hybrid execution modes
- Objectives: Ship selectable modes and reporting.
- Key tasks: Default `--hybrid`; `--aot-strict` (fail on any thunk); `--hybrid=dynamic` (no linked VM; load via host); `aot explain --thunks`.
- DoD: Modes selectable and tested; thunks report spans and sites.
- Dependencies: Phase 5.

### Phase 7 — Testing, fuzzing, and performance
- Objectives: Stabilize quality and performance baselines.
- Key tasks: Golden tests (front-end, rewriter, bytecode); E2E VM/AOT/hybrid; fuzzers (lexer, parser, verifier, decoder); benches (VM throughput, startup, ABI overhead); coverage in CI.
- DoD: Coverage thresholds met; perf baselines recorded.
- Dependencies: Phases 1–6.

### Phase 8 — Developer experience and docs
- Objectives: Introspection tooling and documentation.
- Key tasks: `explain types --site <hir_id>`; `inspect bytecode`; docs under `docs/` for language/CLI/plugins/hybrid; examples.
- DoD: Tools usable; docs published; examples compile and run.
- Dependencies: Phases 2, 4–6.

### Phase 9 — Hardening and release
- Objectives: Determinism, caching, errors/lints, licensing, release.
- Key tasks: Stable IDs/thunk numbering; cache DeepSema summaries; incremental rebuilds; better diagnostics & lint groups; release notes, versioning, publishing.
- DoD: 0.x release cut; installers validated on Win/macOS/Linux.
- Dependencies: All prior phases.

---

## Milestones (release checkpoints)
1. M0: Repo + CI green with empty crates (Phase 0).
2. M1: `kayton run` executes arithmetic/simple functions via VM (Phase 2).
3. M2: Host calls via ABI + stdlib basics (Phase 3).
4. M3: `aot rewrite` produces stable Kayton+ (Phase 4).
5. M4: `aot build` produces native binary; hybrid fallback working (Phase 5).
6. M5: Hybrid modes implemented; `--aot-strict`, `--hybrid=dynamic`, `explain --thunks` (Phase 6).
7. M6: DX tools, fuzz/benches, docs published (Phase 7–8).
8. M7: 0.x release with installers (Phase 9).

---

## Dependencies & sequencing (summary)
- Front-end → FastSema/VM → ABI/Host/Stdlib → DeepSema/Rewriter → Rust backend/RT → Hybrid modes.
- Rewriter depends on DeepSema results and stable `HirId`/symbol interning.
- Rust backend requires bytecode artifacts and runtime to support thunks.

---

## Risks and mitigations
- Value representation parity across VM and AOT runtime
  - Mitigation: Freeze minimal `KayVal` early with explicit versioning.
- Deterministic IDs and thunk numbering
  - Mitigation: Deterministic traversals; seedable hashing; stable interner.
- Scope creep of effects/refined types
  - Mitigation: Feature-gate advanced typing until AOT MVP stabilized.
- ABI/plugin security and versioning
  - Mitigation: ABI version checks; checksums/signatures; deny-unknown by default.

---

## Operating rhythm
- Dev loop: `xtask fmt` → `xtask lint` → `cargo nextest` → `cargo insta review`.
- Local runs: `kayton run examples/*.ktn`; AOT: `kayton aot rewrite|build`.
- Tracing: `RUST_LOG=kayton_*=debug` (`tracing` + `tracing-subscriber`).

---

## Acceptance criteria for v0.1 (0.x)
- VM path runs representative programs and calls stdlib via ABI.
- `aot rewrite` outputs stable Kayton+ with types/specializations visible.
- `aot build` compiles to native binary; non-lowerable sites thunk to VM.
- Hybrid modes selectable and documented; `explain --thunks` reports fallback sites.
- Tests, fuzzers, and benches in place; coverage gates enforced in CI.
- Docs published and installers validated on three major OSes.

---

## References
- See `design/20251004_starting_design_main.md` for architecture overview and hybrid rules.
- See `design/20251004_starting_design_preliminary.md` for crate layout and data-flow.
- See `design/20251001_look of the language.md` for surface design.
- See `design/20251004 steps.md` for the detailed task breakdown.
